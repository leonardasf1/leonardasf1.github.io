<div id="pageTitle">Golang</div>
<div id="pageLogo"><a href="#golang">
    <img src="https://golang.org/favicon.ico" alt="Golang"></a></div>

	<div id="links">
		<a href="https://golang.org/">Golang.org</a><br>
		<a href="https://youtu.be/53ULpInm988">Почему GO?</a><br>
		<a href="https://youtu.be/2fxNbhy2gt0">Плюсы и минусы Go</a>, <a href="https://ater.me/conf/techtrain2018.pdf">презентация</a><br>
    <a href="https://golangify.com/errors">golangify.com/errors</a><br>
		<a href="https://itproger.com/course/one-lesson/14"> go за полчаса</a><br>
		<a href="https://itvdn.com/ru/video/golang">Видео уроки Golang (ITVDN)</a><br>
        <a href="https://geekbrains.ru/events/2287#">напишем на Go простой сканер погоды</a><br>
		<a href="https://play.golang.org/">play.golang.org</a><br>
      <a href="https://www.jetbrains.com/help/go/meet-the-product.html">GoLand IDE</a><br>
		<a href="http://liteide.org/en/">liteIDE</a><br>
    <a href="https://www.youtube.com/channel/UCQBFSUV_BdxGCxeg9Th4EjQ/videos">Gopher School</a><br>
		<a href="https://www.youtube.com/channel/UCq-OB01F8YnS-FJpeJRCvMQ/">GopherCon Russia</a><br>
		<a href="https://groups.google.com/forum/#!forum/golang-ru">Golang Russian</a><br>
		<a href="https://tech.avito.ru">avito.tech</a> , <a href="https://twitter.com/AvitoTech">twitter</a><br>
    gopher.js<br>
    <a href="https://youtu.be/p1ILhiq5Clw">Работа с сетью в Go (2018)</a><br>
    <a href="https://youtu.be/CX4GSErFenI">Как устроен garbage collector в Go 1.9 (2017)</a><br>
    <a href="https://youtu.be/HtQLBdD82vE">Кодогенерация в Go (2017)</a><br>
    Kubernetes<br>
    <a href="https://www.vugu.org/">Vugu: A modern UI library for Go+WebAssembly</a><br>
    <a href="https://youtu.be/uO268voCGwA">Как 200 строк на Go помогли нам освободить 15 серверов – Паша Мурзаков (Badoo)</a><br>
    <a href="https://youtu.be/rcvA5gSwj2o">“Go, please”: language server под микроскопом | Илья Данилкин, Авито. 2020</a><br>
    <a href="https://youtu.be/hKnWq4RmNKE">Работа с миграциями базы данных в Go | Тамара Веденина, Ozon.ru. 2020</a><br>
    <a href="https://youtu.be/mKT-bLdRGvQ">CI/CD для Go проектов на drone.io | Алик Хилажев, Marketplace Technologies. 2020</a><br>
      TLA+/TLC: практичный инструмент формальной верификаций алгоритмов, который точно нужно знать всем гоферам.
      Разрабатывать конкурентные системы сложно. Самые плохие ошибки закладываются в алгоритм, не находятся никакими тестами, и ждут своей уникальной последовательности событий, чтобы взорваться и всё испортить. Но находить такие ошибки можно, даже не написав ни строчки кода на Go — если воспользоваться методами формальной верификации. Один из таких методов — разработанный Лесли Лампортом формализм TLA+ и инструмент верификации TLC — идеально подходит верификации конкурентных систем на Go. Мы поговорим про TLA+/TLC, про PlusCal — транслируемый в TLA+ язык спецификации алгоритмов специально для инженеров
      <br>
	</div>

<div>
<details><summary>terminal</summary>
  <pre><code class="bash">
go run main.go //компиляция и запуск
go build main.go //компиляция пакетов и зависимостей
go build -o ../main.exe main.go //в конкретную папку
go clean //удаляет бинарник
go help
go fmt //форматирование кода
go vet //проверка на ошибки
go test //запускает тесты
go env //показать переменные окружения
go get github.com/username/projectname
  //подгрузка библиотек
go install //компилирует и подгружает библиотеки

echo $GOPATH // путь к проекту
echo $GOROOT // где установен GO
  bin/ бинарники
  pkg/ объектные файлы
  src/ ваш код и др пакеты
  </code></pre>
</details>

  <details><summary>типы данных</summary>
  <pre><code>
    int, int8, int16, int32, int64
    uint, uint8,...
    float32, float64 // 2.3456
    string
    bool
    byte //символьное зн-е % (uint8)
    rune
    error
  </code></pre>
  </details>

  <details>
    <summary>объявление переменных</summary>
    <pre><code>
var age int = 12
age2 := 12 // краткое объявление
a, b := "v1", "v2"
var web string = "itProger"

z:= 2 + 3i // комплексные числа
yu:=`ddd
  dd`
var (
  m0 int = 12
  m2     = "string"
  m3     = 23
)
  </code></pre>
  </details>

  <details>
    <summary>приведение</summary>
    <pre><code>
int(varName) //приведение к типу int
string(symbol) // приведение к типу sting
  </code></pre>
</details>

  <details>
    <summary>string</summary>
    <pre><code>
      len("Word") // 4 длина строки
    </code></pre>
  </details>

  <details>
    <summary>iota (enum)</summary>
    <pre><code>
const (
  z1 = iota + 1 // 1
  z2      // 2
  _
  z3      // 4
)
    </code></pre>
  </details>

  <details>
    <summary>rune</summary>
    <pre><code>
//символы юникода , в ''
      var symbol rune = 'Г' // или '\u1043'
    </code></pre>
  </details>

  <details><summary>if / switch</summary>
    <pre><code>
// только явное преобразование!
if age < 5 {}
else if (age > 5) && (age <= 18) {}
else {}

var ok bool
if r := recover(); r != nil {
  if err, ok = r.(error); ok { fmt.Println(err) }
}

i, ok := varName.(int) //проверка типа
fmt.Println(i, ok)

// Switch case
switch age {
  case 5: fmt.Println("Вам 5 лет")
  case 15: fmt.Println("Вам 15 лет")
    fallthrough  // провалиться в след.кейс
  default: fmt.Println("Вам неизвестно сколько лет")
}

err := GenerateError()
switch e := err.(type) {
  case nil: funcName()
  case *MyError: funcName()
  case error: funcName()
}
  </code></pre>
</details>

<details><summary>For</summary>
  <pre><code>
for { println("бесконечный цикл"); break }
i := 10
for i > 0 {
  fmt.Println(i)
  i--
}
for i := 0; i <= 5; i++ { fmt.Println(i) }

for i, val := range slName {
  println(i, val)
} //как for in (js)

arrCount := make(map[int]int)
for _, val := range slName {
  if _, ok := arrCount[val]; !ok {
    arrCount[val] = 1
  } else { arrCount[val]++ }
}

index := 1
Loop:  // метка для выхода
  for {
    index++
    switch index {
      case 10:
        println()
        goto Loop
      case 2:
        goto Loop2
    }
  }
Loop2:
    fmt.Println()
  </code></pre>
</details>

<details><summary>Array</summary>
  <pre><code class="go">
// у массивов фиксированная длина
var arr [3]int
arr[0] = 45
arr[1] = 97
arr[2] = 76
var a4 [3 * 4]bool
a3 := [...]int{3, 3, 3}
nums := [3]float64 {4.23, 5.23, 98.1}

var aa [3][3]int
aa[1][1] = 1

fmt.Println(arr[1], len(arr))
</code>
сортировка массива
<code>
package main
import "fmt"

func main() {
  arr := [7]int{5, 8, 3, 6, 0, 1, 2}
  var arr1[7]int
  for arr1 != arr {
    arr1 = arr
    for i := 1; i < len(arr); i++ {
      if arr[i-1] > arr[i] {
        arr[i-1], arr[i] = arr[i], arr[i-1] } } }
  fmt.Println("done", arr)
}
  </code></pre>
</details>

<details><summary>Slice <a href="https://habr.com/en/post/202948/" style="float: right">habr?</a></summary>
  <pre><code>
var s1 []int

s1 = append(s1, 100) //add 100
s1 = append(s1, slName...) //add another slice
s1 = append(s1, []int{10, 20, 30, 40}, arr[:]...)

slName := []int{10, 20, 30, 40}

    //копирование
slName := make([]int, 6) //with len
slName := make([]int, 6, 15) //with len & cap
slName := make([]int, len(s1), len(s1))
copy(slName, s1)

var slName []int = arr[1:2] //срез от 1го до 2го
slName[:5], slName[7:]

ar := [...]int{1,2,3} //array
newSlice := a[:]

println(slName[2])

len(slName) // длина
cap(slName) // емкость (1,2,4,8,16,32,...)
make() ?
  </code></pre>
</details>

<details><summary>map (словарь)</summary>
  <pre><code>
//объявленная но не инициализированная карта
var mm map[string]string

//полная инициализация
var mm2 map[int]int = map[int]int{}
mm2 := map[string]string{
  "we": er,
  "rt": ty,
}
mm2["test"] = "ok"

webSites := make(map[string]float64)
webSites["itProger"] = 0.8
webSites["yandex"] = 0.99

fmt.Println(webSites["itProger"])

//проверка на наличие свойства
varName, ok := webSites["yandex"]
fmt.Println(varName, ok)

//и без вывода свойства
_, exist := mapName["keyName"]
fmt.Println(exist)

delete(mapName, "keyName")
  </code></pre>
</details>

<details><summary>Func?</summary>
    <pre><code>
package main
import "fmt"

var globalMap map[string]string
func init() { //запускается до main
  globalMap = make(map[string]string)
  globalMap["myName"] = "Den"
}

func main () {
  var a = 3
  var b = 2
  a, b = summ (a, b)
  var x = 0
  defer pointer (&x) //отложенный запуск
  fmt.Println(a, b, x, summ (a, b))

  //анонимная функция
  func() { fmt.Println("text") }()
  func(su int64) { fmt.Println(su) }(56)
}

func summ(num_1 int, num_2 int) (int, int) {
  var res int = num_1 + num_2
  return res, num_1 * num_2
}
func pointer(x *int) { *x = 2 }

func funcName(varName ...int) int {} //arg - slice

panic() // останавливает основную и выполняет отложенные(defer)
        // функции если в ней был запущен recover()
Только отсроченные функции могут использовать recover
    </code></pre>
</details>

<details><summary>Closure / замыкания</summary>
  <pre><code>
multiple := func() int {
  num *= 2
  return num
}
fmt.Println(multiple())
</code><code class="go">
func funcName() func() int {
  num := 0
  return func() int {
    num +=2
    return num
  }
}
func main() {
  varName := funcName()
  fmt.Println(varName())
}
  </code></pre>
</details>

<details><summary>type</summary>
  <pre><code>
//custom types
type MyInt int
type myType int64
type library []string
type goodLibrary library

var varName MyInt = 10
func funcName(dist myType) {}
  </code></pre>
</details>

<details><summary>Struct</summary>
    <pre><code>
package main
import "fmt"

func main() {
  bob := structName{"Bob", 7, 0.87}
  fmt.Println("Bob function is", bob.test())
}
type structName struct {
  name string  //поля структуры
  age int
  happiness float64
  Firstname string `json:"firstname"` //tag
}
func (a *structName) test() float64 {
  return float64(a.age) * cat.happiness
}  //метод структуры

var varName structName
varName.age = 23
var varName structName = structName{ age: 23 }

var varName *structName = &structName{}
//указатель на тип структуры

b, err := json.Marshal(&varNameWithStruct)
//кодирование структуры в строку JSON
if err != nil { panic(err) }
    </code></pre>
</details>

<details><summary>Embedding</summary>
  <pre><code class="go">
func main() {
  rob := Robocop {
    Robot: Robot { "Gektor", 100 },
    SomeStuff: SomeStuff { move: 200 },
  }
  fmt.Println(rob.Robot.move)
}
  </code></pre>
</details>

<details><summary>Import / Export</summary>
  <pre><code>
import (
  "fmt"
  "github.com/username/projectname"
  usr "user" //use as
  . "user2" //use all in
  _ "notUse"
)
fmt.Println(usr.UserName, UserName2)

// для экспорта 1я буква заглавная
package user
var Username = "Den"
  </code></pre>
</details>

<details><summary>main_test.go</summary>
  <pre><code>
package main

import "testing"

var globalVarN = 5
var globalVarResult = 120

func TestFactorial(t *testing.T) {
  result, i := 1, 1

  for ; i <= globalVarN; i++ {
    result *= i
    println(result)
  }

  if result != globalVarResult {
    t.Errorf("Factorial expected %v but got %v", globalVarResult, result)
  }
}
-------
go test
  </code></pre>
</details>

<details><summary>Interface</summary>
  <pre><code>
type InterfaceName interface {
  FuncName()
  FuncName2() string
}
type StructName struct { поля }
func (b StructName) FuncName() {}
func (b StructName) FuncName2() {}
func FuncName3(f InterfaceName) {
  f.FuncName()
  f.FuncName2()
}
func main() {
  varname := StructName{ "" }
  FuncName3(varName)
  return
}

var varName interface{} = "text"

func funcName(s interface{}) {
  str, ok := s.(string)
  if ok { fmt.Println("text" + str) }
}
  </code></pre>
</details>

<details><summary>& * указатели</summary>
  <pre><code>
<a href="https://youtu.be/Gvf6b3ayaUo"></a>
&varName -  //адрес ячейки в памяти, куда записана переменная
myInt := new(int)
var myIntPointer *int

func main() {
  var number int = 8
  setFivePtr(&number) //передаем адрес
  fmt.Println(number, &number)
}
func setFivePtr(numPtr *int) {
  *numPtr = 5 //изменяем var number в ячейке
}
  </code></pre>
</details>

<details><summary>go-rutine / chan</summary>
  <pre><code>
  c := make(chan string)

  go funcName(c)  //параллельно выполняется
  for i := 0; i < 5; i++ {
    fmt.Println(<-c, ",", <-c)
  } //выводим значения из канала
  <-c //для чтения
  c<- //для записи

  fmt.Scanln() //чтоб успели отработать горутины
---
package main

import (
  "fmt"
  "time"
)

func main() {
  c := make(chan string)

  go ping_pong(c)
  for i := 0; i < 5; i++ {
    fmt.Println(<-c, <-c)
  }

  rangeChan := make(chan int, 10)
  for i := 0; i < 10; i++ { // переполнения, блокируемся в этом месте пока кто-то не прочитает
    rangeChan <- i // тут может заблокироватся
  }
  close(rangeChan) // Закрываем канал и сюда больше нельзя писать иначе паника
  fmt.Println("Sum", sum(rangeChan))

  g := generatorData()
  for i := 0; i < 5; i++ {
    fmt.Printf("Print %d\n", <-g)
  }
}

func ping_pong(c chan<- string) {
  for {
    c <- fmt.Sprintf("Пинг")
    c <- fmt.Sprintf("Понг")
  }
}

func sum(input <-chan int) (res int) {
  for r := range input {
    res += r
  }
  return
}

func generatorData() <-chan int {
  j := make(chan int)
  go func() {
    i := 0
    for {
      if i%2 == 0 { j <- i } 
      time.Sleep(time.Second)
      i++
    }
  }()
  return j
}
  </code></pre>
</details>

</div>

<div>библиотеки
  <pre><code>
import (
  "fmt"
)
  </code></pre>
  <details><summary>"encoding/json"</summary><pre>  
  json.Marshal(&varNameWithStruct)
  </pre>
  </details>
  <details><summary>"fmt"</summary><pre>  
    <a href="https://golang.org/pkg/fmt/">golang.org/pkg/fmt/</a>
<code>
  fmt.Errorf()
  fmt.Printf()
  fmt.Println()
  fmt.Scanln() //чтоб успели отработать горутины
  fmt.Sprintf()

fmt.Sprintf("%#U", 'Г')

fmt.Println(age, int(num), rawSymbol, z, a, b, m0, m2, m3 )
fmt.Println(web, "is cool website\n\t", z1, z2, z3, yu)

// Printf
fmt.Printf("%t", isDone)
fmt.Printf("Факториал числа %d равен %d\n", n, f)

%T-тип
%t-bool
%d-int,uint,rune,byte
%f-float64,float32
%s-string
%b-byte
%v-all
"hi\n\t"
\n //новая линия
\t //большой пробел
  </code></pre></details>
  "math/rand"
  <details><summary>"time"</summary><pre>  
  time.Since(time.Now) //прошедшее время
  time.Sleep(time.Second) //timeout 1sec
  time.Time
  time.Date(2000,4,22,0,0,0,0,time.UTC)
  </pre></details>
  <details><summary>"runtime"</summary><pre>  
  runtime.Stack(varName, false)
  </pre></details>
  <details>
    <summary>"strcony"</summary>
  </details>
  <details>
    <summary>"net/http"</summary>
    <pre><code>
http.ResponseWriter
http.Request
http.HandleFunc("/", home_page)
http.ListenAndServe(":8080", nil) //запуск сервера
// для остановки сервера - ctrl+c
    </code></pre>
  </details>
  <details>
    <summary>"database"</summary>
    <pre><code>

import (
  "fmt"
  "database/sql"
  _ "github.com/go-sql-driver/mysql"
)
func main() {
  db, err := sql.Open("mysql", "root:root@tcp(127.0.0.1:8889)/golang")
  if err != nil { panic(err) }
  defer db.Close()

  insert, err := db.Query("INSERT INTO `users` (`name`, `age`) VALUES('Bob', 35)")
  if err != nil { panic(err) }
  defer insert.Close()

  res, err := db.Query("SELECT `name`, `age` FROM `users`")
  if err != nil { panic(err) }
  for res.Next() {
    var user User
    err = res.Scan(&user.Name, &user.Age)
    if err != nil { panic(err) }
    fmt.Println(fmt.Sprintf("User: %s with age %d", user.Name, user.Age))
  }
}
    </code></pre>
  </details>
</div>

<div>
  <details>
    <summary>сортировка пузырьком</summary>
    <pre><code>
func main() {
  nums := []int{2, 5, 1, 8, 7, 3, 4, 6, 9}
  fmt.Printf("not sort %d \n", nums)

  for i := 0; i < len(nums)-1; i++ {
	for j := 0; j < len(nums)-i-1; j++ {
      counter++
	  if nums[j] > nums[j+1] {
		nums[j], nums[j+1] = nums[j+1], nums[j]
      }
    }
  }
  fmt.Printf("sort %d count %d \n", nums, counter)
}
    </code></pre>
  </details>
</div>

<div>
  <details>
    <summary>Шаблонизаторы</summary>
    <pre><code>

  < h1>Главная страница</ h1>

{{ if eq .Name "Bob"}}
< span>Ну привет!< /span>
{{ else }}
< span>А ты кто?< /span>
{{ end }}

  < p>Пользователь: {{ .Name }}< /p>
    </code></pre>
  </details>
</div>