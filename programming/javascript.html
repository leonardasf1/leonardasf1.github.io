<div id="pageTitle">JavaScript</div>
<div id="pageLogo"><a href="#javascript">
    <img src="../icons/js.svg" alt="javascript"></a></div>

<div id="links">
  <a href="https://learn.javascript.ru/js"><img src="http://learn.javascript.ru/img/favicon/favicon.png" alt="learn.javascript.ru"></a>
  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference" style="padding-left: 0"><img src="https://developer.mozilla.org/static/img/favicon32.7f3da72dcea1.png" alt="mozilla"></a>
  <a href="https://www.ecma-international.org/ecma-262/"><img src="https://www.ecma-international.org/ecma-262/img/favicon.ico" alt="ecma"></a>
  <a href="https://kangax.github.io/compat-table/"><img src="https://kangax.github.io/compat-table/favicon.ico" alt="es6"></a>
  <a href="http://plnkr.co/"><img src="http://plnkr.co/img/plunker.png" alt="plunker"></a>
  <a href="https://jsfiddle.net/"><img src="http://jsfiddle.net/img/favicon.png" alt="jsfiddle"></a>
  <a href="https://eloquentjavascript.net"><img src="https://eloquentjavascript.net/favicon.ico" alt="EJS"></a>
  <a href="https://skillbox.ru/media/code/javascript_glavnyy_instrument_frontend/"><img src="https://skillbox.ru/favicon.ico" alt="Skillbox"></a>
  <br><br>
  <a href="https://www.youtube.com/playlist?list=PLqKQF2ojwm3l4oPjsB9chrJmlhZ-zOzWT">Сложный JavaScript простым языком. Владилен Минин (2019)</a><br>
  <a href="https://youtu.be/v6AVfIupNB8">Композиция или Наследование в JavaScript?</a><br>
  <a href="https://youtu.be/3OQkiILpxjA">MoscowJS MeetUp 2020.01</a><br>
  <a href="https://github.com/azat-io/you-dont-know-js-ru">"Вы не знаете JS"</a><br>
  <a href="https://webref.ru/tech/javascript">WebRef</a><br>
  <a href="https://vk.com/doc7608079_488265969">Секреты JavaScript Ниндзя</a><br>
  <a href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a><br>
  <a href="https://www.youtube.com/playlist?list=PLqHlAwsJRxAPHWjsHt64z9Jq1nTxRncrL"> Знакомство с JavaScript (CodeDojo.2018)</a><br>
  <a href="https://www.youtube.com/playlist?list=PLqHlAwsJRxAOpWPtj2T6HhSzX-lKmKV2q"> Основы ES6 (CodeDojo.2017)</a><br>
  <a href="https://www.youtube.com/watch?v=T3IgBNN9bhM&list=PLVfMKQXDAhGUaEtJ_fOUz0F7TJtidE7Qw"> Уроки JavaScript (Web Developer Blog.2016)</a><br>
  <a href="https://www.youtube.com/watch?v=JISFx18J7nc&list=PLVfMKQXDAhGW0p_BEEe47UkCgNoS_dyki"> Практика JavaScript (Web Developer Blog.2016)</a><br>
  <a href="https://www.youtube.com/watch?v=o8oyT0WJfHE&list=PL8pp2EAvIK-KybxnPezLLiEEfLfle11_i"> JavaScript для начинающих (Денис Горелов.2017)</a><br>
</div>

<div>Основы
	<ul>
		<li><details><summary>Типы данных</summary>
			<pre><code>
  Логический тип данных.
  Данные хранящиеся в переменной булевого типа могут принимать два значения:  
  истина (true) и ложь (false). 
  //Часто истина представляется единицей, а ложь — нулем. 

  Null // это тип данных, указывающий на отсутствие объекта.
  //В JavaScript null не является «ссылкой на несуществующий объект» 
  //или «нулевым указателем», как в некоторых других языках.
  Null // значение, аналогичное понятиям: «ничего» или «значение неизвестно».

  undefined // это тип данных, который используется для переменных или свойств объекта,
  // значения для которых не существует или оно не присвоено. 

  let test = "hello"; // string
  let test2 = 123; // number
  let test3 = true; // boolean
  let test4 = new Array(); // object
  let test5 = new Date(); // object

  typeof // С помощью оператора typeof можно получить строку указывающую тип операнда.
  //Оператор typeof может быть удобен для того что бы отличить объект от базового типа.
  document.write(typeof test); 
typeof null; // <s>object</s>
typeof () => {}; // <s>function</s>
typeof test5.toString; // function

  function printMessage(message) {
    if (typeof message != "string") {  // проверка типа параметра функции
      alert("Параметр должен быть строкового типа!");
    } else {
      document.write(message);
    }
  }
  printMessage(new Array());
  printMessage("Hello world");
			</code></pre></details></li>
		<li><details><summary>Преобразование типов</summary>
			<pre><code>
	parseFloat();  // преобразование в вещественное значение
	parseInt();  // преобразование в целочисленное значение

  +string // преобразование строчного в числовое значение

  //Конкатенация - операция склеивания объектов линейной структуры, обычно строк.
  // Значение в переменной (a) неявно преобразуется в строку
  document.write(str + a);

  // Значение в переменной str неявно преобразуется в число
  document.write(str - a);
  document.write(str * "2");
  document.write(str / "2");
			</code></pre></details></li>
		<li><details><summary>Операторы</summary>
			<pre><code>
    = assigns a value 
Оператор присвоения "=" предназначен для присвоения определенного значения переменной. 
            Арифметические операторы:

        var a = 9;
        var b = 5;
        var result;

        // Сложение (+)
        result = a + b; // в данном случае + арифметическое сложение.
document.write("a + b = " + result); // в данном случае оператор + выполняет операцию конкатенации.

        // Вычитание (-)
result = a - b; // в случае если a или b нечисловые, оператор пытается преобразовать их в числа.
        document.write("a - b = " + result);

        // Умножение (*)
        result = a * b;
        document.write("a * b = " + result);

        // Деление (/)
        result = a / b;
document.write("a / b = " + result); // деление на 0 дает +/- бесконечность. 0/0 дает NaN.

//возведение в степень
  a**b

                a % b;    Деление c остатком (Деление по модулю) - это операция, 
             которой возвращаемое значение является остатком от деления.


            В отличие от некоторых других языков, оператор "+" делает конкатенацию, 
    если хотя бы один операнд - строка, причем, не обязательно первый.

        var a = -8;
        var string = "10";

        // Унарный минус (-)
        result = -a; // Операция смены знака на противоположный.
        document.write("-a = " + result);

        // Унарный плюс (+)
        // не изменяет знака при применении к числовому типу (ничего не происходит). 
        result = +a;
        document.write("+a = " + result);

        // Унарный плюс (+)
        // при применении к строковому типу, преобразовывает его в числовой.
        result = +string + a;
        document.write("+string + a = " + result);

        Инкремент — операция, во многих языках программирования используемая 
        для увеличения значения переменной на единицу.

        Имеется префиксная и постфиксная форма инкремента. 
        Префиксный инкремент выполняется перед использованием переменной.
        Постфиксный инкремент выполняется после использования переменной.

        var a = 9;

    Постфиксный инкремент

        document.write(a);   // выведет 9
        a++;
        document.write(a);   // выведет 10
        document.write(a++); // выведет 10
        document.write(a);   // выведет 11

    Префиксный инкремент

        document.write(a);   // выведет 11
        ++a;
        document.write(a);   // выведет 12
        document.write(++a); // выведет 13
        document.write(a);   // выведет 13

    Декремент — операция, во многих языках программирования используемая 
        для уменьшения значения переменной на единицу.

        Имеется префиксная и постфиксная форма декремента. 
        Префиксный декремент выполняется перед использованием переменной.
        Постфиксный декремент выполняется после использования переменной.

        var a = 9;

    Постдекремент

        document.write(a);   // выведет 9
        a--;
        document.write(a);   // выведет 8
        document.write(a--); // выведет 8
        document.write(a);   // выведет 7

    Предекремент

        document.write(a);   // выведет 7
        --a;
        document.write(a);   // выведет 6
        document.write(--a); // выведет 5
        document.write(a);   // выведет 5

        Специальные простые операторы

        a += 3; // a = a + 3;

        a -= 3; // a = a - 3;

        a *= 3; // a = a * 3;

        a /= 3; // a = a / 3;

			</code></pre></details></li>
		<li><details><summary>Операторы сравнения</summary>
			<pre><code class="javascript">
  == checks a value to another
  Оператор равенства "==" предназначен для сравнения значений двух переменных, 
     при этом необходимо помнить о следующих правилах:

  1. если одно значение null а другое undefined - значения равны.
  2. если одно значение число, а второе строка, то строка преобразоваться в число и производиться сравнение.
  3. если одно значение true оно преобразуется в 1, если значение false оно преобразоваться в 0.

  === checks a value & type
    Идентичность - требует совпадения типа и значения переменной, 
  когда для равенства достаточно только совпадающих значений.

  Оператор идентичности "===" предназначен для проверки значений двух переменных на идентичность, 
  при этом необходимо помнить о следующих правилах:

  1. если значения имеют разные типы они не идентичны.
  2. если значения являются числами имеют одинаковые значения и не являются значения NaN - они идентичны.
  3. если две строки имеют одинаковую длину и содержат одни и те же символы - они идентичны.
  4. два одинаковых логических значения идентичны.

  != Оператор неравенства "!=" возвращает противоположное значение оператора равенства.
  !== Оператор неидентичности "!==" возвращает противоположное значение оператора идентичности.

  < , > , <= , >= Операторы сравнения .
      Сравнение строк производиться посимвольно для числовых значений каждого символа из кодировки Unicode.
      Символ в верхнем регистре считается меньше символа в нижнем регистре.
      Например: A - code (41 Hex)
                a - code (61 Hex)
			</code></pre></details></li>
		<li><details><summary>alert, prompt, confirm</summary>
			<pre><code>
	alert('message');
	prompt('question','default'); ok > input.value, cancel > null
	confirm(); ok > true, cancel > false
			</code></pre></details></li>
		<li><details><summary>if, else, '?'</summary>
			<pre><code>
	if (сравнение) {}  // если
	else if (сравнение) {}
	else {}

  //Тернарная условная операция
	name = (сравнение) ? x : y; //вычисленное значение возвращается

	if ("t" in name) {} //проверка наличия свойства
			</code></pre>
		</details></li>
		<li><details><summary>Логические операторы</summary>
			<pre><code>
    & bitwise AND
    ^ bitwise XOR
    | bitwise OR
    && logical AND . Логическое И (&&) - возвращает true тогда и только тогда когда оба операнда равны true.
    || logical OR . Логическое ИЛИ (||) - возвращает true, если первый или второй операнд (или оба) равны true.
			</code></pre></details></li>
		<li><details><summary>Циклы: while, for</summary>
			<pre><code>
  while (сравнение) { i++; x; }  пока
  do { x; i++; } while (сравнение);
  for (let i = 0; i < 10; i++) {}
  for (; ;) { name = x; y; }

  for (let i in array) { array[i] } // перебор массива

  for (let value of args) { value } // перебор значений

  for (let [key, value] of Object.entries(object1)) {  // перебор объекта
  	console.log(`${key}: ${value}`);
  }
  async function funcName() {
    for await (const obj of promises) {
      console.log(obj)
    } // ждёт выполнения промисов в каждом цикле
  }
  <b>Метки.</b>
  Инструкция метки (label) используется вместе с break или continue для альтернативного выхода из цикла. 
  Оно добавляется перед блочным выражением в качестве ссылки, которая может быть использована в дальнейшем.
  Вместо оператора goto.
  Label: for (let j = 0; j < 2; j++) {
    for (var i = 0; i < 2; i++) {
      let input = prompt("Введите любой текст, чтобы выйти нажмите отмена", '');
      if (input == null) break Label; //выйти сразу из 2-х циклов.
      continue Label;
      document.write(input + " ");
    }
    Label1: for (let i = 0; i < 2; i++) {
      let input = prompt("Введите любой текст, чтобы выйти нажмите отмена", '');
      if (input == null) break Label1; //выйти сразу из 2-х циклов.
      continue Label1;
      document.write(input + " ");
    }
    document.write("br");
  }
			</code></pre>
		</details></li>
		<li><details><summary>switch ..case</summary>
			<pre><code>
	switch (varName) {
		case "varValueA":
		case "varValueB": {ab} break;
		case "varValueC": {c} break;
		default: {} break;
	}
  // Тип значения выражения селектора и значений постоянных выражений операторов case должны совпадать.
			</code></pre></details></li>
	</ul>
</div>

<div>Типы данных
	<ul>
		<li><details><summary>Number</summary>
			<pre><code class="javascript">
      JS  64-битный формат IEEE-754.
  1.23e6 = 1.23 * 1000000
  1e-3 = 1 / 1000 (=0.001)
  0xff // 255 16-иричная 0..9 или A..F
  0o377 // 255 8-иричная
  0b11111111 // бинарная 0 или 1
  2n9c     // 36-иричная 0..9 или A..Z

  let num = 255;
  num.toString(16)  // ff
  num.toString(2)  // 11111111
  123456..toString(36) // 2n9c

  Math
  .calc()
  .floor //Округление в меньшую сторону
  .ceil //Округление в большую сторону
  .round //Округление до ближайшего целого
  .trunc //Производит удаление дробной части без округления
  num.toFixed(2);  //"255.00" для устранения JS-неточности
  // возвращает строку

  Number
  .NEGATIVE_INFINITY // минус бесконечность
			</code></pre></details></li>
		<li><details><summary>String</summary>
			<pre><code>

    var mss = "Welcome " + name + name + "!";
    let msg = `Welcome ${name + name}!`.toUpperCase();
  `hello ${who}`

  Methods

  String.fromCharCode(e.charCode)  // введеный символ 
  String​.from​Code​Point()
  ​.anchor()
  ​.big()
  ​.blink()
  ​.bold()
  ​.charAt();      //возвращает символ по указанной позиции
  ​.char​CodeAt()
  ​.code​PointAt()
  ​.concat()
  ​.ends​With()
  ​.fixed()
  ​.fontcolor()
  ​.fontsize()
  ​.includes()
  ​.indexOf("");  //возвращает индекс первого встречающегося в строке указанного символа 
  ​.italics()
  ​.last​IndexOf("");  //возвращает индекс последнего встречающегося в строке указанного символа 
  ​.link()
  ​.locale​Compare() //
  ​.match();       // принимает регулярное выражение и возвращает массив с результатами поиска
  ​.matchAll()
  ​.normalize()
  ​.padEnd(20, '-'); // добавляет в конец строки n-кол-во - до длины 20;
  ​.pad​Start(10, '_'); // добавляет в начало строки n-кол-во _ до длины 10;
  ​.quote()
  ​.repeat()
  ​.replace( , ""); //  производит операцию поиска с заменой
  ​.search(); // возвращает индекс первого найденного символа подстроки по шаблону или -1 если подстрока не найдена
  ​.slice()
  ​.small()
  ​.split("");   //Разбивает строку на подстроки по указанному разделителю и возвращает массив подстрок.
  ​.starts​With('He');  //проверяет начинается ли строка с аргумента, boolean 
  ​.strike()
  ​.sub()
  ​.substr(0, 2); //возвращает строку начиная с указанного индекса, указанной длины
  ​.substring(0, 2); //возвращает строку между двумя указанными индексами, не включая индексы
  ​.sup()
  ​.toLocale​Lower​Case()
  ​.toLocale​Upper​Case()
  ​.toLower​Case(); //перевод всех символов в нижний регистр
  ​.toSource()
  ​.toString()
  ​.toUpper​Case(); //перевод всех символов в верхний регистр
  ​.trim()
  ​.trimEnd()
  ​.trim​Start()
  ​.valueOf()
  String​.prototype​[@@iterator]()
  String​.raw()

    new String();
			</code></pre></details></li>
		<li><details><summary>Array</summary>
			<pre><code>
	//массивы
    var name = Array(1, 2, 3, 4, 5, 6);
  Array(4) // [,,,]
  Array.from(arr) // создает массив из arr
    Array.from(arr, elem => elem * 2) // как в .map()
  Array.isArray(obj) // if (obj is array) return true : false
  Array.of(7) // [7]
    Array.of(1, 2, 3) // [1, 2, 3]
  arr.concat(new elems or arr) // return new Array(...arr, new elems or arr)
    .concat(input) // добавляет в массив введенное значение
  .copyWithin(,); //(target,start,end)
        [1,2,3,4,5].copyWithin(0,3,5); // [4,5,3,4,5]
  .entries() // return CreateArrayIterator()
        ['a','b','c'].entries() .next().value; //[0,'a']
  .every(elem => elem >= 10); // true or false
        arr.every(funcName);
        function funcName(elem, index, array) {
          return elem >= 10;
        } // проверяет соответствие всех элементов условиям функции
  .fill(value, start, end) // fill with value from start until end
        .fill(0,2,4); .fill(5,1); .fill(7);
  .filter(elem => elem.length > 5); //return new Array with elem.length > 5
        .filter(funcName); //фильтрует элементы по условиям функции
  .find(elem => {});  //return elem соответствующий условиям функции
        .find(funcName);
  .findIndex(elem => {}); //return index of elem соответствующего условиям функции
        .findIndex(funcName); // if not return -1
  .flat(x) // return new Array уменьшая вложенность на х-уровней и delete пустые слоты
        .flat(); .flat(2); .flat(Infinity);
  .flatMap(elem => {}) // map().flat(1)
        .flatMap(funcName); //return new Array
  .forEach(elem => {});
        .forEach(funcName);
        .forEach((elem, index, array) => {
          alert(`${elem} имеет позицию ${index} в ${array}`);
        });
  .includes(elem, from); //if elem? return true : false
        .includes(elem);
  .indexOf(elem, from); //return first index of elem, if !elem return -1
        .indexOf(elem);
  .lastIndexOf(item, from) //return last index of elem, if !elem return -1
  .join(' ')  // преобразует все элементы массива в строки и объединяет их
      // аргумент станет разделителем вместо запятых
  .keys() //return new Array Iterator ключей всех индексов arr
  .length // длина массива
  .map(elem => elem * 2) //создаёт новый массив с результатом вызова указанной функции для каждого элемента массива
        .map(funcName);
  .pop() //delete last element, return deleting element
  .push() //append element(s), return lenght
  .reduce(funcName, initValue);// if (initValue) {prevElem = initValue(once)} 
        .reduce(funcName);
        function funcName(prevElem, curElem, index, array) {
          return prevElem * curElem;
        }
  .reduceRight() // тоже самое в обратную сторону
  .reverse() // revers original array
  .shift() //delete first element, return deleting element
  .slice(start, end); // return new array
    .slice(3); // возвращает подмассив от указанного индекса до конца массива
    .slice(1, -2); //Если аргумент отрицательный - он задает позицию относительно конца массива
  .some(elem => elem >= 10); // true or false
        .some(funcName); // проверяет, соответствует ли какой-либо элемент условиям функции
  .sort() // Сортирует элементы массива в Unicode порядке 
  //(при необходимости временно преобразуя элементы в строки для выполнения сравнения).
    arr.sort(function (a, b) { //или в порядке заложенном функцией
      return a > b;
    });
  .splice(startIndex, deleteCount, [addedElements]);
    .splice(5,1); //delete elem with index 5
  .toLocaleString(); //преобразует массив в одну строку
  .toString(); //преобразует массив в одну строку
  .unshift() // добавляет элемент в начало массива, return length
  .values() //return new Array Iterator всех значений arr

  .split // connect stroke in massive

  Array.prototype[@@iterator]()

  [1, 2, 3, 4, 5, 6];
  name[1];
  var name = new Array();
  document.write(new Array(4).join('xa'));
			</code></pre></details></li>
		<li><details><summary>Iterable</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Map, Set</summary>
			<pre><code>
  Map  // объект без прототипа , любые ключи
  let myMap = new Map();
  let keyString = 'a string',
      keyObj = {},
      keyFunc = function() {};
  // setting the values
  myMap.set(keyString, "value associated with 'a string'");
  myMap.set(keyObj, 'value associated with keyObj');
  myMap.set(keyFunc, 'value associated with keyFunc');
  myMap.size; // 3
      .clear()
      .delete()
      .entries()
      .forEach()
      .get()
      .has()
      .keys()
      .set()
      .values()
  Map.prototype[@@iterator]()

  Set  // массив ,значения не повторяются
  let mySet = new Set();
  mySet.add(1); // Set [ 1 ]
  mySet.add(5); // Set [ 1, 5 ]
  mySet.add(5); // Set [ 1, 5 ]
  mySet.add('some text'); // Set [ 1, 5, 'some text' ]
  let o = {a: 1, b: 2};
  mySet.add(o);
  mySet.add({a: 1, b: 2}); // o is referencing a different object so this is okay
      .add()
      .clear()
      .delete()
      .entries()
      .forEach()
      .has()
      .values()
  Set.prototype[@@iterator]()
			</code></pre></details></li>
		<li><details><summary>WeakMap, WeakSet</summary>
			<pre><code>
	WeakMap  // ключи только объекты
    let wm2 = new WeakMap();

    let o1 = {},
    o2 = function() {},
    o3 = window;
	// a value can be anything, including an object or a function
    wm2.set(o1, o2);
    wm2.set(o3, undefined);
    wm2.set(wm1, wm2);
	// keys and values can be any objects. Even WeakMaps!
    .delete()
    .get()
    .has()
    .set()

    WeakSet
    let ws = new WeakSet(),
    foo = {},
    bar = {};

    ws.add(foo);
    ws.add(bar);

    WeakSet.prototype.add();
    WeakSet.prototype.delete();
    WeakSet.prototype.has();
			</code></pre></details></li>
		<li><details><summary>Destructuring assignment</summary>
			<pre><code>
	// Деструктуризация <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">.</a>

  let [,,mu,ars,mc = 'default'] = Array
  // присваиваем переменным значения элементов массива
  function funcName([x, y, ...z]) { console.log(x, y) }
  funcName(arrName);

  let { name, age, country } = Object
  // записываем элементы объекта в одноименные переменные
  let { name: userName, age:userAge, social: { vk }, country } = Object
  // или в переменные с другими именами

			</code></pre></details></li>
		<li><details><summary>Date, time</summary>
			<pre><code>
  new Date(2019,0,1);  // 1 янв 2019
  // при вызове конструктора Date без параметров, создается объект Date отражающий текущую дату и время
    .setFullYear()
    .getFullYear()
    .toGMTString()
  performance.now() // источники времени
  process.hrtime()
  <a href="https://gist.github.com/victor-homyakov/eaecea956d3679cbbec76578ede311fb">"Тяжёлое бремя времени"</a>

  codepen: 
  <a href="https://codepen.io/leonardasf1/pen/qzeLrz">secundomer</a> 
  <a href="https://codepen.io/leonardasf1/pen/QXeJJG">time</a>
			</code></pre></details></li>
		<li><details><summary>JSON</summary>
      <pre><code>

    JSON.stringify для преобразования объектов в JSON.
    JSON.parse для преобразования JSON обратно в объект.

      </code></pre></details></li>
    <li><details><summary>Binary</summary>
      <pre><code>
  ArrayBuffer бинарные массивы
  TextDecoder , TextEncoder
  Blob
  File , FileReader
      </code></pre></details></li>
	</ul>
</div>

<div>Object
	<ul>
		<li><details><summary>Object</summary>
			<pre><code>
  let name = {
    t:a,
    s:x,
    r:this.t
  }  // Создание объекта через блок инициализации.

  let name = {}    // пустой объект

  name.t = a;
  name["s"];  // Присвоение новых значений свойствам.

  let name = new Object();

  delete name.t; //удаляет свойство
  if("имя_свойства" in объект)  //проверка наличия свойства
  .hasOwnProperty("")  //проверка наличия свойства

  .getItem("key");
  .setItem("key","value");
  .deleteItem("key");

  Object.assign(target, source); //клонировать {}source в {}target
  let varName = Object.assign({}, source);
  Object.create(prototipe, { prop-s }) // создает объект из 
                // прототипа, с необязательными свойствами
  Object.defineProperties()
  Object.defineProperty(obj, prop, descriptor) //определяет новое или изменяет существующее
  // свойство непосредственно на объекте, возвращая этот объект.
  Object.entries(); // keys & values
  Object.freeze()
  Object.fromEntries()
  Object.getOwnPropertyDescriptor(obj, prop); //получить дескриптор свойства prop
  Object.getOwnPropertyDescriptors(obj, prop); //то же самое с get и set
  Object.getOwnPropertyNames()
  Object.getOwnPropertySymbols()
  Object.getPrototypeOf()
  Object.is()
  Object.isExtensible()
  Object.isFrozen()
  Object.isSealed()
  Object.keys(objName)  // массив ключей
  Object.seal()  // массив значений??
  Object.setPrototypeOf()
  Object.values()  // массив значений

  function funcName(property, value) {
    return {
      [property]: value,
      ['_' + property]: value,
      [property.toUpperCase()]: value,
      ['get' + property]() {
        return this[property];
      }
    }
  }

  Garbage Collector // сборка мусора
  объект удаляется из памяти если недостижим из корня
			</code></pre></details></li>
		<li><details><summary>Symbol</summary>
			<pre><code>
  let varName = Symbol('Name');
  let varName = Symbol.for('symbolName');
  console.log(Symbol.keyFor('varName'));
			</code></pre></details></li>
		<li><details><summary>this</summary>
			<pre><code>
function Cat(color) {
  this.color = color;
  console.log(this);
  (() => console.log(this))();
}
new Cat('red');
			</code></pre></details></li>
		<li><details><summary>Преобразование</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>new</summary>
			<pre><code>
	function Name(x, y) {   // Функция-конструктор для
		this.t = x;        // создания объектов Name.
		this.s = y;
	}
	var name = new Name(x, y);   name.t

	Name.prototype.r = x;  // Метод прототипа
	Name.prototype = name  // наследование
			</code></pre></details></li>
		<li><details><summary>Object.keys,..</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Флаги и дескрипторы</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>get, set</summary>
			<pre><code>
  Object.defineProperty(obj, 'propName3', {
    get: function() {
      return this.propName1 + '' + this.propName2;
    }
    set: function(value) { this.propName1 = value; }
  });

  {
    get propName() {
      return this.propName1 + '' + this.propName2;
    },
    set propName(value) { this.propName1 = value; }
  }
			</code></pre></details></li>
	</ul>
</div>

<div>function
	<ul>
		<li><details><summary>function</summary>
			<pre><code>

  function Name() {}
          .arguments  // обращение к аргументам функции как к массиву
  имя_функции( аргументы );
  let name = new Function("аргументы", "тело");
  (function () {})();   // немедленно вызываемая анонимная функция

  function Name() {x;<b title="Оператор return указывает на возвращаемое значение функции, которое будет передано при следующей форме вызова:">return</b> y;}
  var Name = function(a, b) {return a + b;}

  function max(a, b, c) { 
    var maxValue = Number.NEGATIVE_INFINITY;
    for (i in arguments){
      if (arguments[i] > maxValue) maxValue = arguments[i];
    }
    return maxValue;
  }
  var res = max(-33, 33, 777, -666, -22, 888);
  document.write("Максимальное значение аргументов функции = " + res);
			</code></pre></details></li>
		<li><details><summary>expressions, =></summary>
			<pre><code>
  // стрелочные функции
  let add = (x, y) => x + y;
  let square = x => x * x;
  let log = () => console.log('Logging');
  let multiply = (x, y) => {...; ...};
  let getPerson = () => ({ name: 'John' });
  (() => console.log('IIFI'))();

  let person = {
    name: 'Bob',
    greet: function() {
      setTimeout(() => {
        console.log(`Hello, ${this.name}`);
      }, 2000);
    }
  };

  const name = параметры => {};
  const name = (a=4,b) => a+b  // если параметр "a" не будет
  // указан при вызове функции "a" присвоит себе значение 4.

  // У стрелочной функции нет своего arguments и this;
			</code></pre></details></li></details></li>
		<li><details><summary>Recursion, стек</summary>
			<pre><code>
  function f(counter) {
    counter--;
    document.write(`Down: ${counter}< br>`);
    if (counter != 0) f(counter);
    document.write(`Up: ${counter}< br>`);
  }
  f(3);
			</code></pre></details></li>
		<li><details><summary>rest, spread</summary>
			<pre><code>
  // rest_parameters
  function f (a, b, ...arrName) {}
  // задаём массив в качестве агумента
  function sum(...values) {
    values.forEach();
  }
  sum(5, 7, 2, 10);

  // spread - добавляем элементы других массивов/объектов
  let obj3 = { ...obj1, ...obj2 };
  let array3 = [ ...arr1, ...arr2];
			</code></pre></details></li></details></li>
		<li><details><summary>Замыкание</summary>
			<pre><code>
  let person = {
    name: 'Bob',
    greet: function() {
      let _this = this;
      setTimeout(function() {
        console.log(`Hello, ${_this.name}`);
      }, 2000);
    }
  };

  const fib = [1, 2, 3, 5, 8, 13];
  for (var i = 0; i < fib.length; i++) {
    (function(j) {
      setTimeout(function() {
        console.log(`fib[${j}] = ${fib[j]}`);
      }, 1500);
    })(i);
  }

			</code></pre></details></li>
		<li><details><summary>@ decorators</summary>
			<pre><code class="js">
<a href="https://github.com/tc39/proposal-decorators">github.com/tc39/proposal-decorators</a>
<a href="https://learn.javascript.ru/call-apply-decorators">learn.javascript.ru/call-apply-decorators</a>
<a href="https://youtu.be/VfF7GyNItps">JS Decorators Никита Дубко (2018)</a>

const meetup = Object.defineProperties({}, {
  name: {
    value: 'MinskJS',
    writable: true,
    enumerable: true,
    configurable: true
  }
})
function decorator(id) {
  return function(target, name, descriptor) {}
}

@classDecorator
class MyClass {
  @propertyDecorator
  property = 42

  @methodDecorator
  someMethod() {}
}

function decorName(target, name, descriptor) {
  const fn = descriptor.value;
  descriptor.value = function(...args) {
    fn.apply(target, args);
    return target;
  }
}
class ClassName {
  @decorName
  methodName(x) { this.x = x; }
  method2Name() { console.log(this.x); }
}
const p = new ClassName();
p.methodName('Bruce').method2Name();
			</code></pre></details></li>
		<li><details><summary>setTimeout, setInterval</summary>
			<pre><code>
  setTimeout(funcName, 5000);   // запустит x через 5сек
  setInterval(funcName, 1000); // будет запускать x каждую 1секунду
  clearTimeout(name);   // отменяет запуск
  clearInterval(name);  // останавливает setInterval

  setTimeout(() => {}, 3000);
  setTimeout(function() {}, 3000);

			</code></pre></details></li></details></li>
		<li><details><summary>bind, call, apply</summary>
			<pre><code>
// применяем на объекте метод другого объекта,
// добавляя значения недостающих свойств.
obj1Name.obj1MethodName.bind(obj2Name, prop3Val, prop4Val)();
obj1Name.obj1MethodName.call(obj2Name, prop3Val, prop4Val);
obj1Name.obj1MethodName.apply(obj2Name, [prop3Val, prop4Val]);
			</code></pre></details></li>
    <li><details><summary>Memoize</summary>
      <pre><code>
  // Мемоизация - прием кэширования результатов функции.
  function calcFib(x) {
      // проверка наличия результата для параметра x.
      if (!calcFib.cache[x]) { // если результат не найден то производим вычесления.
          if (x > 1) {
              calcFib.cache[x] = calcFib(x - 1) + calcFib(x - 2);
          }
          else { calcFib.cache[x] = x }
      }
      return calcFib.cache[x];
  }
  // создание свойства в функции с пустым объектом.
  calcFib.cache = {};
  for (let i = 0; i < 40; i++) {
      document.write(`${i} = ${calcFib(i)} < br />`);
  }
      </code></pre></details></li>
	</ul>
</div>

<div>Prototypes
	<ul>
		<li><details><summary>Наследование</summary>
			<pre><code>
  function Human(name) {  // базовая функция-конструктор
      this.name = name;
      this.talk = function () { document.write("Hello My Name is " + this.name) }
  }

  function Student(name) {  // производная функция конструктор
      this.name = name;
      this.school = "CBS school";
  }

  function Worker(name) {
      this.name = name;
      this.speciality = "Software developer";
  }

  var human = new Human("name");  // Создаем экземпляр родителя
  //human.talk(); 

  Student.prototype = human;  // наследуем Student и Worker от Human устанавливая функцию как прототип.
  Worker.prototype = human; 
  Worker.talk = function () { document.write("Привет мое имя " + this.name) }    
  // переопределение метода из базовой функции-конструктора (override).
  
  var Alex = new Student("Alexander");
  var Andrew = new Worker("Andrew");

  Alex.talk();
  document.write(Alex.school);

  Andrew.talk();
  document.write(Andrew.speciality);


  function Box(x, y, z, w) { 
      this.height = x;
      this.width = y;
      this.depth = z;
      this.material = w;
  }
  Box.prototype.volume = function () {
    return this.height * this.width * this.depth;
  }
  Box.prototype.Equals = function(otherObj){
    return this.material === otherObj.material;
  }
  var box1 = new Box(15, 21, 13, "steel");
  var box2 = new Box(20, 20, 13, "steel");
  document.write(box1.volume() + ", " + box2.volume() + ", ");
  document.write(box1.Equals(box2));
			</code></pre></details></li>
		<li><details><summary>function-prototype</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>native-prototypes</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>prototype-methods</summary>
			<pre><code>
  // переопределение метода valueOf из Object
  Rectangle.prototype.valueOf = function () {
      return this.getArea();
  }
  var rect1 = new Rectangle(100, 200);
  document.write(rect1.valueOf());
			</code></pre></details></li>
	</ul>
	Classes
	<ul>
		<li><details><summary>class</summary>
			<pre><code>
  class MyClass {
    prop = value; // свойство
    constructor(...) { // конструктор
      // ...
    }
    method(...) {} // метод
    get something(...) {} // геттер
    set something(...) {} // сеттер
    [a + d]() {} // метод с вычисляемым именем
    ...
  }

  class User {
    lastName = "Аноним";
    constructor(name) {
      this.name = name;
    }
    get name() { return this._name }
    set name(value) {
      if (value.length < 4) {
        alert("Имя слишком короткое.");
        return;
      }
      this._name = value;
    }
    sayHi() { alert(this.name + user.lastName) }
    ['say' + 'Hii']() { alert("Привет") }
  }
  // создание объекта класса:
  let user = new User("Иван");
  alert(user.name + user.lastName); // use get
  user.name = "Юля!"; // use set
  user.sayHi();  // use method
  user.sayHii();
---
  function makeClass(phrase) {
    // объявляем класс и возвращаем его
    return class {
      sayHi() { alert(phrase) };
    };
  }
  // Создаём новый класс
  let User = makeClass("Привет");
  new User().sayHi(); // Привет
			</code></pre></details></li>
		<li><details><summary>extends</summary>
			<pre><code>

  class Dog extends Animal {
    constructor(name) {
      super(name); // call the super class constructor and pass in the name parameter
    }
    speak() {
      console.log(`${ this.name } barks.`);
    }
  }
  class Lion extends Cat {
      speak() {
          super.speak();
          console.log(`${ this.name } roars.`);
      }
  }
			</code></pre></details></li>
		<li><details><summary>Static</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Private, protected</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>instanceof</summary>
			<pre><code>
  instanceof // оператор для проверки типа объекта
  class Task {}
  let task = new Task();
  console.log(task instanceof Task);
			</code></pre></details></li>
		<li><details><summary>Mixins</summary>
			<pre><code>

			</code></pre></details></li>
	</ul>
</div>

<div>promise
	<ul>
		<li><details><summary>callbacks</summary>
			<pre><code>
  var add = function (a, b) { return a + b }
  var sub = function (a, b) { return a - b }

  function show(callBack, a, b) {
    var result = callBack(a, b);
    document.write(result);
  };
  show(add, 10, 20);
  show(sub, 50, 30);
			</code></pre></details></li>
		<li><details><summary>promise</summary>
			<pre><code>
  function myAsyncFunction (url) {
    return new Promise((resolve, reject) => {
      resolve("ок");
      reject(new Error("Ошибка!"));
    })
    .finally(() => остановить индикатор загрузки)
    // выполнится, когда промис завершится, независимо от того, успешно или нет
    .then((result) => {})
    .catch(alert) // Error: Ошибка!
    .then((results) =>  //выполнится после обработки ощибки
      results.forEach(result =>
        funcName(result)));
  }
  Promise.all([funcName(), func2Name()]);
  Promise.allSettled()
  Promise.prototype.finally()
  Promise.race()
			</code></pre></details></li>
		<li><details><summary>promise-chaining</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>API</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>promisify</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>microtask queue</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>async/await</summary>
			<pre><code>
    // await можно использовать только внутри async–функций
  async function showAvatar() {  // функция в любом случае вернёт промис
    // запрашиваем JSON с данными пользователя
    let response = await fetch('/article/promise-chaining/user.json');
    let user = await response.json(); 

    // запрашиваем информацию об этом пользователе из github
    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
    let githubUser = await githubResponse.json(); 

    // отображаем аватар пользователя
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);  

    // ждём 3 секунды и затем скрываем аватар
    await new Promise((resolve, reject) => setTimeout(resolve, 3000));
    img.remove();
    await new Promise((resolve, reject) => setTimeout(resolve, 1000));
    document.write("готово!")
  }
  showAvatar()
    .catch(alert);
			</code></pre></details></li>
	</ul>
  <details><summary>try..catch, err, throw</summary>
      <pre><code>
  async function f() {

    try {
      let response = await fetch('/no-user-here');
      let user = await response.json();
    } catch(err) { // перехватит любую ошибку в блоке try
      alert(err);
    }
  }
  ---
  funcName()
    .catch(alert); // перехватит любую ошибку в funcName()
    .catch(err => alert(err)); // то же самое
    .catch(err => alert(err.massege));
  ---
  async function f() {
    await Promise.reject(new Error("Упс!"));
  }
  ---
  async function f() {
    throw new Error("Упс!");
  }
  ---
  new Promise((resolve, reject) => {})
    .catch(error => {
      if (error instanceof URIError) {}
      else {
        alert("Не могу обработать ошибку");
        throw error; // пробрасывает эту или другую ошибку в следующий catch
    }})
    .then((result) => {})  // не выполнится
    .catch(err => alert(`Неизвестная ошибка: ${err}`));
  ---
  // отслеживает необработанные ошибки
  window.addEventListener('unhandledrejection', function(event) {
    // объект события имеет два специальных свойства:
    alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
    alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
  });
  ---
  Error.message;
      </code></pre></details>
</div>

<div>
	<ul>
		<li><details><summary>generators</summary>
			<pre><code>
  <a href="https://youtu.be/LxhVf0dxNCM">.</a> , <a href="https://learn.javascript.ru/generators">learn.js</a>
  function* generatorFunc() {
    let result = yield 3;
    console.log(result); // 3
    yield 1;
  }
  let iterator = generatorFunc();
  console.log(iterator.next()); // Object {value: 3, done: false}
  console.log(iterator.next()); // Object {value: 1, done: false}
  console.log(iterator.next()); // Object {value: undefined, done: true}
  console.log(iterator.next().value);
  console.log(iterator.return()); // Object {value: undefined, done: true}
  console.log(iterator.throw(new Error('error'))); // Error: error

  let generatorFunc = function*() {};
  class SomeClass {
    *generatorFunc() {}
  }
			</code></pre></details></li>
		<li><details><summary>modules, import, export</summary>
			<pre><code>
  import defaultExport from "./module-name.js";
  import * as name from "./module-name.js";
  import { export1 } from "./module-name.js";
  import { export1 as alias1 } from "./module-name.js";
  import { export1 , export2 } from "./module-name.js";
  import { foo , bar } from "./module-name.js";
  import { export1 , export2 as alias2 , [...] } from "./module-name.js";
  import defaultExport, { export1 [ , [...] ] } from "./module-name.js";
  import defaultExport, * as name from "./module-name.js";
  import "./module-name.js";
  let promise = import("./module-name.js");

	// Exporting individual features
  export let name1, name2, …, nameN; // also var, const
  export let name1 = …, name2 = …, …, nameN; // also var, const
  export function functionName(){...}
  export class ClassName {...}

  // Export list
  export { name1, name2, …, nameN };

  // Renaming exports
  export { variable1 as name1, variable2 as name2, …, nameN };
  // Exporting destructured assignments with renaming
  export const { name1, name2: bar } = o;

  // Default exports
  export default expression;
  export default function (…) { … } // also class, function*
  export default function name1(…) { … } // also class, function*
  export { name1 as default, … };

  // Aggregating modules
  export * from …;
  export { name1, name2, …, nameN } from …;
  export { import1 as name1, import2 as name2, …, nameN } from …;
  export { default } from …;
			</code></pre></details></li>
		<li><details><summary>dinamic-imports</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Proxy, Reflect</summary>
			<pre><code>
let varName = {
  get: function(target, name) {
    return (name in target) ? target[name] : 42;
  }
};
let p = new Proxy({}, varName);
p.a = 1;
console.log(p.a, p.b); // 1, 42
			</code></pre></details></li>
		<li><details><summary>Eval</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Carrying</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Intl</summary>
			<pre><code>

			</code></pre></details></li>
    <li><details><summary>WebSocket</summary>
      <pre><code>npm i ws -save
        WSS://
события:
  onopen //при установке соединения
  onclose
  onmessage //при получении данных
  onerror

webSocket.send(data) //отправка данных на сервер
      </code></pre></details></li>
    <li><details><summary>Web Components</summary>
      <pre><code>

      </code></pre></details></li>
      <li><details><summary>Service Worker API</summary>
      <pre><code>
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">mozilla</a>
        <a href="https://habr.com/ru/company/2gis/blog/345552/">habr</a>
        <a href="https://developers.google.com/web/fundamentals/primers/service-workers">google</a>
        serviceWorker
 (applicationCache)
    </code></pre></details></li>
    <li><details><summary>Web Worker </summary>
      <pre><code>
    Worker() <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">.</a>

  Properties

    onerror
    onmessage
    onmessageerror

  Methods

    postMessage()
    terminate()
    </code></pre></details></li>
    <li><details><summary>canvas </summary>
      <pre><code>
  < canvas id="canvas">< /canvas> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">.</a>

  function init() {
 
    var canvas = document.getElementById("canvas");  // получение элемента
    var context = canvas.getContext("2d");  //  и его графического контекста.

    context.save();    // сохраняем копию текущего состояния контекста.
    context.translate(100, 100);    // переносим начало координат.
    ***
    context.restore();    // восстанавливаем прежнее состояние контекста.

    context.beginPath();    // начало пути
    context.moveTo(100, 100);  // первая точка
    context.lineTo(100, 200);  //  Переход в точку с координатами (100,200)
    context.closePath();    // Замыкаем путь
    context.stroke();    // черчение линии на холсте.

    context.fillRect(100, 100, 400, 300);    // прямоугольник (x,y,width,height) x,y - Начало координат
    context.strokeRect(0, 60, 150, 50);  // прямоугольник без заливки
    context.clearRect(80, 80, 35, 35);  // очистка прямоугольной области от контента

    context.lineWidth = 20;    // толщина линии
    context.strokeStyle = "green";  // цвет линий
    context.fillStyle = "blue";  // цвет заливки
    context.fill();  // залить
    context.lineJoin = "miter"; "round"; "bevel";  //Определяем форму вершин, в которых сходятся линии

    context.quadraticCurveTo(/*управляющая точка*/350, 50, /*вторая точка*/600, 300);  // дуга
    context.bezierCurveTo(/*управляющая точка 1*/50, 90,/*управляющая точка 2*/ 159, -30,/*вторая точка*/ 200, 30);
    context.createPattern(item, 'repeat-x');  // повторяет указанный элемент по указанному направлению

    //arc(x,y,radius,startAgle,endAngle,clockwise)  //  сектор
    //Метод arc() принимает 6 аргументов:
    //x, y - центр рисования дуги
    //radius -радиус
    //startAngle -начальный угол окружности
    //endAngle - конечный угол окружности
    //clockwise - направление прорисовки. false - по часовой стрелке
    context.arc(100, 100, 50, 0, Math.PI*2, true);

    context.scale(x, y);  // масштабирование
    context.rotate(angle);  // вращение, угол
    context.transform(scaleX, skewX, skewY, scaleY, transformX, transformY);

    var logo = new Image();                        
    logo.onload = function () {
        context.drawImage(logo, 5, 5);
    };
    logo.src = "canvas.jpg";

  //градиенты
    // Создание объекта градиента и указание начальной и конечной точки оси градиента.
    var gradient = context.createLinearGradient(0, 0, 270, 270);
    // Добавление цвета и смещения позиции остановки цвета.
    gradient.addColorStop(0, "Black");
    gradient.addColorStop(0.35, "Blue");
    gradient.addColorStop(1, "White");
    // Установка объекта градиента в качестве цвета заливки контекста.
    context.fillStyle = gradient;

    // Создаем массив цветов для цветовой модели
    var hue = [[255, 0, 0], [255, 255, 0], [0, 255, 0], [0, 255, 255], [0, 0, 255], [255, 0, 255]],
      gradient = context.createLinearGradient(0, 0, elem.width, 0);
    // Добавляем цвета остановки
    for (var i = 0; i <= 5; i++) {
        color = 'rgb(' + hue[i][0] + ', ' + hue[i][1] + ', ' + hue[i][2] + ')';
        gradient.addColorStop(i * 1 / 6, color);
    }
    context.createRadialGradient(150, 150, 100, 150, 150, 200);
        // (x1,y1,radius1,x2,y2,radius2)
  //текст
    context.font = "bold 24px Segoe UI";
    context.textBaseline = "alphabetic";  // top, bottom, middle,hanging, alphabetic
    context.fillText("text", (context.canvas.width - context.measureText("text").width) / 2, 198);
  //тень
    context.shadowColor = "rgba(255, 0, 0, 1)";
    context.shadowOffsetX = 5;
    context.shadowOffsetY = 5;
    context.shadowBlur = 50;  //Степень размытия
  //прозрачность
    context.globalAlpha = 0.5;

    context.canvas.width
    context.canvas.height
  }

  codepen:
  <a href="https://codepen.io/leonardasf1/pen/YmGmRW">pingpong</a>
  <a href="https://codepen.io/leonardasf1/pen/PMbPLw">draw</a>
  <a href="https://codepen.io/leonardasf1/pen/bXBKba">CanvasAnimRect</a>
  <a href="https://codepen.io/leonardasf1/pen/EqNzbj">CanvasDiagramm</a>
  <a href="https://codepen.io/leonardasf1/pen/VomogL">SunSistem</a>
  </code></pre></details></li>
    <li><details><summary>js-animation</summary>
      <pre><code>
  window.requestAnimationFrame
  </code></pre></details></li>
	</ul>
</div>

<div>Dom
	<ul>
		<li><details><summary>DOM</summary>
			<pre><code>
  // Методы для работы с DOM (узлы или строки)
    .append('');  // добавляет в конец
    .prepend('');  // добавляет в начало
    .after('')  // после
    .before('')  // перед
    .replaceWith('')  // заменяет
    .remove()
    .appendChild();  // добавить дочерний элемент
    .insertBefore()  // добавить элемент перед указанным
    .removeChild();  // удаление дочернего элемента
    .replaceChild()  // замена одного элемента на другой

  document.create​Element('тэг')

    .textContent = ; // вставить текст
	document.create​TextNode('text')
	.insertAdjacentText('afterend', 'text')

    .innerHTML = "";  // заполнить HTML-кодом
  .insertAdjacentHTML('beforebegin', `html`);  // вставить HTML-код
  .insertAdjacentHTML('afterbegin', `html`);
  .insertAdjacentHTML('beforeend', `html`);
  .insertAdjacentHTML('afterend', `html`);

	.insertAdjacentElement('', 'elem')

	.tagName

	.nodeType
  // Основные типы узлов
  //  Константа nodeType              | Значение nodeType
  // ---------------------------------------------------
  //  Node.ELEMENT_NODE               | 1
  //  Node.ATTRIBUTE_NODE             | 2*
  //  Node.TEXT_NODE                  | 3
  //  Node.CDATA_SECTION_NODE         | 4
  //  Node.ENTITY_REFERENCE_NODE      | 5*
  //  Node.ENTITY_NODE                | 6*
  //  Node.PROCESSING_INSTRUCTION_NODE| 7
  //  Node.COMMENT_NODE               | 8
  //  Node.DOCUMENT_NODE              | 9
  //  Node.DOCUMENT_TYPE_NODE         | 10
  //  Node.DOCUMENT_FRAGMENT_NODE     | 11
  //  Node.NOTATION_NODE              | 12*
  // ---------------------------------------------------
			</code></pre></details></li>
		<li><details><summary>навигация по DOM</summary>
			<pre><code class="js">
  document.querySelector('')  // селекторы как в CSS , возвращает первый найденный
    .querySelectorAll('')  // возвращает массив всех

  document.get​Element​ById("")
    .get​Elements​ByClass​Name()
    .get​Elements​ByName()
    .get​Elements​ByTagName()

    .children
    .childNodes       // массив всех дочерних узлов
    .firstElementChild
    .firstChild       // первый дочерний узел
    .lastElementChild
    .lastChild        // последний дочерний узел
    .nextElementSibling
    .nextSibling      // следующий узел расположенный на одном уровне с текущим
    .previousElementSibling
    .previousSibling  // предыдущий узел расположенный на одном уровне с текущим
    .parentNode       // родительский узел для текущего элемента
    .hasChildNodes

    .get​Animations()
    .get​BoxObjectFor()
    .get​Elements​ByTagNameNS()
			</code></pre></details></li>
    <li><details><summary>document</summary>
      <pre><code>
 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document">.</a>
  navigator
          .appName // Название веб браузера.
          .appVersion // Номер версии или другая информация о браузере
          .userAgent // строка, которую браузер посылает в HTTP заголовке USER-AGENT
          .appCodeName // Кодовое имя браузера.
          .platform // Аппаратная платформа, на которой работает браузер.
  history.forward()
      .backward()
  window.screenLeft
  window.screenTop
  window.innerWidth // ширина окна
  window.innerHeight // высота окна
  window.getComputedStyle(element, null)[styleName] // получение значений стилей
  screen.width  // ширина экрана
  screen.height // высота экрана

  let name = window.open(
  "window.html",
  "Window Name",
  "width=400,height=400,status=yes,resizable=no");
      name.close();
        <div style="float: left;">Methods:

  .adopt​Node()
  .caret​Range​From​Point()
  .clear()
  .close()
  .create​Attribute()
  .create​CDATASection()
  .create​Comment()
  .create​Document​Fragment()
  .create​ElementNS()
  .create​Entity​Reference()
  .create​Event()
  .create​Expression()
  .create​Node​Iterator()
  .create​NSResolver()
  .create​Processing​Instruction()
  .create​Range()
  .create​Text​Node()
  .create​Touch()
  .create​Touch​List()
  .create​Tree​Walker()
  .enable​Style​Sheets​ForSet()
  .evaluate()
  .exec​Command()
  .exit​Fullscreen()
  .exit​Pointer​Lock()
  .has​Focus()
  .has​Storage​Access()
  .import​Node()
  .moz​SetImage​Element()
  .open()
  .query​Command​Enabled()
  .query​Command​Supported()
  .register​Element()
  .release​Capture()
  .request​Storage​Access()
  .write()
  .writeln()      // + перевод строки</div><div>Properties:

  .body
    characterSet
    childElementCount
    children
    compatMode
    contentType
    cookie
    currentScript
    defaultView
    designMode
    dir
    doctype
  .documentElement.clientWidth  // ширина окна
  .documentElement.clientHeight // высота окна
    documentURI
    domain
    embeds
    firstElementChild
    forms
    fullscreenEnabled
    head
    hidden
    images
    implementation
    lastElementChild
    lastModified
    lastStyleSheetSet
    links
window.location.replace('url');  // направление на другой адрес
    .location   // весь url
    .location.protocol // протокол
    .location.host     // имя хоста
    .location.pathname // путь к запрашиваемому ресурсу
    .location.search   // строка запроса (после знака вопроса)
    .location.hash  // #...
    plugins
    preferredStyleSheetSet
    readyState
    referrer  // адрес документа, содержащего ссылку, которая привела на текущую страницу
    scripts
    scrollingElement
    selectedStyleSheetSet
    styleSheetSets
    title
    URL
    visibilityState</div>
      </code></pre></details></li>
		<li><details><summary>Events</summary>
			<pre><code>
  a href="javascript:alert('Hello')">Ссылка /a>
  селектор.событие = function () {};  
  тэг onclick="имяФункции();"
  селектор.["событие"] = function () {};

  .addEventListener("событие без on", function(){});  // добавляет событие
  .addEventListener("event", funcName);
  .removeEventListener("событие без on", funcName, false);  //  удаление обработчика

	document.attachEvent();  // for IE<=8
          .dispatchEvent(event)

  abort   // прерывание загрузки img
  animationcancel    
  animationend
  blur            // элемент теряет фокус
  cancel
  canplay
  canplaythrough
  change        // Элемент потерял фокус и его значения с момента получения фокуса изменилось
  cuechange
  durationchange
  ended
  error             // ощибка при загрузке изображения
  focus
  gotpointercapture
  input
  invalid

  lostpointercapture

  pause
  play

  pointercancel
  pointerdown
  pointerenter
  pointerleave
  pointermove
  pointerout
  pointerover
  pointerup

  reset        // запрос на очистку полей формы
  resize       // изменение размера окна
  submit()       // Запрос на передачу данных формы
  transitioncancel
  transitionend
  unhandledrejection  // обработчик ошибок

  //Properties
  .bubbles   // Логическое значение, указывающее, вспыло ли событие вверх по DOM или нет.
  .cancelable  // Логическое значение, показывающее возможность отмены события
  .cancel​Bubble  // отмена всплытия
  .composed
  .current​Target  // узел чей обработчик события работает в данный момент.
  .default​Prevented  // Показывает, была ли для события вызвана функция event.preventDefault().
  .event​Phase  // Указывает фазу процесса обработки события (1/2/3)
  .explicit​Original​Target  // Явный первоначальный целевой объект события (Mozilla-специфичный).
  .isTrusted   // Показывает было или нет событие инициировано браузером или из скрипта
  .original​Target  // Первоначальный целевой объект события до перенаправлений (Mozilla-специфичный).
  .return​Value  // присвоить false для предотвращения выполнения операции по умолчанию.
  .src​Element  // Нестандартный синоним для Event.target
  .target    //  элемент, который был инициатором события
  .time​Stamp // объект Date, указывающий, когда произошло событие
  .type       // Название события (без учета регистра символов).

    //Methods

  .composed​Path
  .create​Event  // Создаёт новое событие
  .init​Event   // Инициализация значений события
  .prevent​Default();         // отменяет стандартное действие
  .stop​Immediate​Propagation   // ля конкретного события не будет больше вызвано обработчиков.
  .stop​Propagation();        // останавливает перемещение события по DOM

	codepen: <a href="https://codepen.io/leonardasf1/pen/bGbpYjO">Event-add-remove</a>
			</code></pre></details></li>
		<li><details><summary>interface event</summary>
			<pre><code>

  ('copy', (e) => {alert('Копирование запрещено'); e.preventDefault();});
  ('paste', (e) => {.innerText = 'Введите текст. Вставка запрещена'; e.preventDefault();});
        keydown          // клавиша нажата
        keypress         // клавиша дала символ
        keyup            // клавиша отпущена
  // mouse:
        click         // Была нажата и отпущена клавиша мыши
        dblclick          // Двойной щелчок
        contextmenu  // клик правой кнопкой мышки
        mousedown
        mouseenter
        mouseleave
        mousemove     // Перемещение указателя мыши
        mouseout     // курсор вышел за пределы элемента.
        mouseover    // курсор вошел в пределы элемента.
        mouseup
	('wheel', (e) => { .innerText = deltaY })  // генерируется над 
	// любым элементом, не важно, прокручиваемый он или нет. 
        scroll  // над прокручиваемыми елементами
        select        // Выбор текста

    // MouseEvent <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"></a>
    // Properties

  .altKey           // true если клавиша Alt зажата.
  .button          // 0 - левая клавиша, 1 - средняя клавиша, 2 - правая.
  .buttons
  .charCode        // код символа (передается при событии keypress)
  .clientX / .clientY   // координаты относительно левого верхнего угла документа.
  .ctrlKey              // true если клавиша Ctrl зажата.
  .deltaY – количество прокрученных пикселей по вертикали
  .keyCode // код клавиши для события keydown и keyup или код unicode символа для события keypress
  .layerX / .layerY    // координаты относительно элемента в котором произошло событие.
  .metaKey
  .movementX / .movementY
  .moz​Input​Source
  .offsetX / .offsetY    // координаты относительно элемента в котором произошло событие.
  .pageX / .pageY
  .region
  .related​Target
  .screenX / .screenY   // координаты относительно экрана.
  .shiftKey             // true если клавиша Shift зажата.
  .WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN
  .WEBKIT_FORCE_AT_MOUSE_DOWN
  .webkit​Force
  .which
  .x / .y

  // Methods

  //get​Modifier​State()
  init​Mouse​Event
			</code></pre></details></li>
		<li><details><summary>Element</summary>
			<pre><code>
	 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">.</a>
  Properties

  .accessKey
  .attributes
  .child​Element​Count
  .class​List
  .class​Name
  .client​Height
  .client​Left
  .clientTop
  .client​Width
  .current​Style
  .id
  .local​Name
  .name
  .namespaceURI
  .onfullscreenchange
  .onfullscreenerror
  .open​OrClosed​Shadow​Root
  .outer​HTML // весь код блока включая сам блок
  .prefix
  .runtime​Style
  .scroll​Height
  .scroll​Left
  .scroll​LeftMax
  .scrollTop
  .scroll​TopMax
  .scroll​Width
  .shadow​Root
  .slot
  .tab​Stop
  .tag​Name

	Methods

  .after()
  .animate()
  .attach​Shadow()
  .before()
  .closest()
  .computed​StyleMap()
  .create​Shadow​Root()
  .get​Animations()
  .get​Attribute()
  .get​Attribute​Names()
  .get​Attribute​Node()
  .get​Attribute​NodeNS()
  .get​AttributeNS()
  .get​Bounding​Client​Rect()
  .get​Client​Rects()
  .has​Attribute()
  .has​AttributeNS()
  .has​Attributes()
  .has​Pointer​Capture()
  .insert​Adjacent​Element()
  .insert​Adjacent​HTML()
  .insert​Adjacent​Text()
  .matches()
  .msZoomTo()
  .release​Pointer​Capture()
  .remove()
  .remove​Attribute()
  .remove​Attribute​Node()
  .remove​AttributeNS()
  .replace​With()
  .request​Fullscreen()
  .request​Pointer​Lock()
  .scroll()
  .scrollBy()
  .scroll​Into​View()
  .scroll​Into​View​IfNeeded()
  .scrollTo()
  .set​Attribute()
  .set​Attribute​Node()
  .set​Attribute​NodeNS()
  .set​AttributeNS()
  .set​Capture()
  .set​Pointer​Capture()
  .toggle​Attribute()
			</code></pre></details></li>
		<li><details><summary>HTMLElement</summary>
			<pre><code>
	Properties  <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement">.</a>

  .content​Editable
  .context​Menu
  .dir
  .hidden
  .inner​Text
  .isContent​Editable
  .lang
  .nonce
  .offset​Height / .offset​Width         // высота / ширина элемента
  .offsetLeft / .offsetTop         // смещение элемента относительно родительского узла
  .offset​Parent
			</code></pre></details></li>
		<li><details><summary>HTMLMedia​Element</summary>
			<pre><code>
	Properties  <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement">.</a>

  audio​Tracks
  autoplay        // воспроизведение сразу после загрузки
  buffered
  controller
  controls        // элементы управления воспроизведением
  controls​List
  cross​Origin
  currentSrc      // адрес медиафайла (чтение)
  current​Time     // текущее положение в клипе ,сек.
  default​Muted
  default​Playback​Rate
  duration        // длительность (чтение)
  ended      // true, если воспроизведение завершено (чтение)
  error       // код ошибки, если возникла (чтение)
  initial​Time
  loop        // если true, зацикливание воспроизведения
  media​Group
  muted       // отключение звука
  network​State
  onerror
  paused      // true, если приостановлен (чтение)
  playback​Rate
  ready​State
  seekable
  sinkId
  src
  src​Object
  text​Tracks
  video​Tracks
  volume      // громкость от 0.0 до 1.0

	Methods // управляющие функции

  can​Play​Type()     // проверить способность проигрывать указанный тип MIME
  capture​Stream()
  fast​Seek()
  load()                  // загрузить и подготовить к воспроизведению
  msInsert​Audio​Effect()
  pause()             // приостановить
  play()              // загрузить (если необходимо) и воспроизвести
  requestFullscreen()
  seek​ToNext​Frame()
  //set​Media​Keys()
  //set​SinkId()

	Events

  abort
  canplaythrough
  error
  loadeddata
  loadstart
  play
  playing
  progress
  timeupdate
  volumechange
  waiting
			</code></pre></details></li>
		<li><details><summary>attributes</summary>
			<pre><code>
  < style>
    .div[data-info="name"] { color: green }
    .div[data-info="age"] { color: blue }
  < /style>
  < div class='div' data-info="name">< /div>
  < div class='div' data-info="age">< /div>

  < script>
    let user = {
      age: 25,
      name: "Pete"
    };
    for(let i of document.querySelectorAll('[data-info]')) {
      // i.innerHTML = user[i.getAttribute('data-info')];
      i.innerHTML = user[i.dataset.info];
    }
  < /script>

  .href = 'новая/ссылка'; 
  .href  // получаем полный адрес

  elem.className
  .classList.contains('');  // проверка наличия класса, возвращает true/false.
  .classList.add('');
  .classList.remove('');
  .classList.replace('old', 'new')
  .classList.toggle("class")  // добавить класс, если его нет, иначе удалить.

  .style.fontSize = '23px';
  .style['fontSize'] = '23px';

  .style.cssText = `        // Полная перезапись стилей
      color: red !important;
      background-color: yellow;
      width: 100px;
      text-align: center;
    `;

  const root = document.querySelector(':root');
  //прочитать глобальную CSS-переменную
  const styles = getComputedStyle(root);
  const primary = styles.getPropertyValue('--primary-color');
  //записать новое значение
  root.style.setProperty('--primary-color', 'green');

  .setAttribute("href", "url");
  .removeAttribute("href");
  .getAttribute("href");  // получаем строку из html
  .hasAttribute('');  // проверяет наличие атрибута
  .attributes  // все атрибуты элемента
  	.includes('')  // содержит
  	.startsWith('')  // начинается с 
			</code></pre></details></li>
		<li><details><summary>Forms</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>..load..</summary>
			<pre><code>

  window.onbeforeunload = function () { return "Данные не сохранены. Точно перейти?" };
             // Событие произойдет перед закрытием страницы.
  window.onload = function () {}  // событие срабатывает после полной загрузки окна.
  DOMContentLoaded

  loadeddata
  loadedmetadata

//события на елементы
  loadstart
  load
  loadend
			</code></pre></details></li>
		<li><details><summary>MutationObserver</summary>
			<pre><code>

			</code></pre></details></li>
		<li><details><summary>Selection, Range</summary>
			<pre><code>

			</code></pre></details></li>
    <li><details><summary>Drag & Drop</summary>
      <pre><code>
    атрибут draggable="true"

  // dragstart - вызывается в самом начале переноса перетаскиваемого элемента.
  // dragend - вызывается в конце события перетаскивания - как успешного, так и отмененного.
  // dragenter - происходит в момент когда перетаскиваемый объект попадает в область целевого элемента.
  // dragleave - происходит когда перетаскиваемый элемент покидает область целевого элемента.
  // dragover - происходит когда перетаскиваемый элемент находиться над целевым элементом.
  // drop - вызывается, когда событие перетаскивания завершается отпусканием элемента над целевым элементом.

    .addEventListener('dragstart', function () {}, false);
    .addEventListener('dragend', function () {}, false);
    target.addEventListener('dragenter', function () {}, false);
    target.addEventListener('dragleave', function () {}, false);
    target.addEventListener('dragover', function () {}, false);
    target.addEventListener('drop', function () {}, false);

  // Свойство DataTransfer – место, где реализуется перетаскивание. Оно содержит часть данных,
  // отправляемых при выполнении этого действия. Объект dataTransfer устанавливается в событии dragstart,
  // а считывается и обрабатывается в событии drop. 
  // Свойство effectAllowed управляет визуальным эффектом (чаще всего это вид указателя мыши),
  // который браузер создает в ответ 
  // на тип происходящего  события перетаскивания (перемещение, копирование и т. п.).

    .dataTransfer.effectAllowed = "move";

  // Метод setData(...) сообщает механизму перетаскивания в браузере, какие данные из перетаскиваемого объекта должен «поймать»
  // целевой элемент, также называемый зоной приема. Здесь мы указываем, что передаваемые данные это id элемента
  evt.dataTransfer.setData("Text", this.id);

  codepen: <a href="https://codepen.io/leonardasf1/pen/LwVXyZ">drag & drop</a>
  </code></pre></details></li>
    <li><details><summary>geolocation</summary>
      <pre><code>
  navigator.geolocation.getCurrentPosition() 
  .textContent = position.coords.latitude;  // широта
  .textContent = position.coords.longitude;  // долгота
  .textContent = position.coords.accuracy;  // точность(м)
  .textContent = position.coords.altitude;  // высота
  .textContent = position.coords.altitudeAccuracy;  // точность высоты
  .textContent = position.coords.heading;  // курс (направление) при движении(получаем градус отклонения от севера. 90deg - восток, 270deg - запад)
  .textContent = position.coords.speed;  // скорость движения(м/с).

  // options: необязательный объект в методе getCurrentPosition
  // { 
  //   enableHighAccuracy: true, - попытаться получить наиболее точные данные - более длительная загрузка координат
  //   timeout: 2000, - данные должны быть получены в течении 2 секунд.
  //   maximumAge: 30000 - если данные были получены в течении последних 30 секунд их можно не запрашивать заново.
  // }
  navigator.geolocation.getCurrentPosition(updateLocation, handleError, { enableHighAccuracy: true, timeout: 2000, maximumAge: 30000 });

  navigator.geolocation.watchPosition()
            //Функция watchPosition работает аналогично getCurrentPosition, но возвращает 
            // объект-таймер, через который будет повторно вызываться операция поиска местоположения
            // maximumAge: 1000 - каждую секунду нам будет возвращаться текущее положение

  navigator.geolocation.clearWatch();  //clearWatch - удаляет таймер для обновления поиска расположения
  </code></pre></details></li>
	</ul>
</div>

<div>
	<ul>
		<li><details><summary>Storage</summary>
			<pre><code>
	window.sessionStorage
	window.localStorage //5Mb String only
		.setItem("key1", "value1")
		.getItem()
		.deleteItem()
		.clear()

  document.cookie = "name=value; max-age=3600 / expires=*";

	encodeURIComponent()
	decodeURIComponent()
	codepen: 
	<a href="https://codepen.io/leonardasf1/pen/gVeGXG">StorageColor</a> 
	<a href="https://codepen.io/leonardasf1/pen/JgOmYE">cookieColor</a>
			</code></pre></details></li>
		<li><details><summary>indexedDB</summary>
			<pre><code>
  .indexedDB
      .open('baseName', 1);  // открытие БД
          .onupgradeneeded = (e) => {}
          .onsuccess  // обработка успеха
          .onerror  // обработка ошибок

  .objectStoreNames.contains('Text')  // объект всех БД в хранилище
  .createObjectStore('Text', { keypath: 'id', autoIncrement: true });
  .transaction(['Text'], 'readwrite/readonly');
      .objectStore('Text');
          .add();

			</code></pre></details></li>
		<li>AJAX<ul><details><summary>Fetch</summary>
			<pre><code>
  let promise = fetch(url, {options});
  ---
  let response = await fetch('url');
  let results = await response.json();
  alert(results[0].author.login);
  alert(results.message);
  ---
  fetch('url')
  .then(response => response.json())
  .then(results => alert(results[0].author.login))
  .catch(alert);
  .catch(err => document.write(err));

  response.status // код статуса HTTP-запроса, например 200.
  response.ok // true, если статус ответа в диапазоне 200-299.
  response.headers  // похожий на Map объект с HTTP-заголовками.

  response.text() // возвращает ответ как обычный текст,
  response.json() // декодирует ответ в формате JSON,
  response.formData() // возвращает ответ как объект FormData,
  response.blob() // возвращает объект как Blob,
  response.arrayBuffer() // возвращает ответ как ArrayBuffer,
  response.body // это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. 
    // использовать только один метод чтения ответа!

  alert(response.headers.get('Content-Type')); // application/json; charset=utf-8
  // перебрать все заголовки
  for (let [key, value] of response.headers) {
    alert(`${key} = ${value}`);
  }
  let response = await fetch('/article/fetch/post/user', {
    method: 'POST',  // метод запроса
    headers: {  // заголовки запроса
      'Content-Type': 'application/json;charset=utf-8'
    },
    body: JSON.stringify(user)  // тело запроса
  });
			</code></pre></details></li>
		<li><details><summary>FormData</summary>
			<pre><code>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('url', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };

  formData.append(name, value) – добавляет к объекту поле с именем name и значением value,
  formData.append(name, blob, fileName)
  formData.delete(name) – удаляет поле с заданным именем name,
  formData.get(name) – получает значение поля с именем name,
  formData.has(name)

    // Список пар ключ/значение
  for(let [name, value] of formData) {
    alert(`${name} = ${value}`); // key1=value1, потом key2=value2
  }
			</code></pre></details></li>
		<li><details><summary>XMLHttpRequest</summary>
			<pre><code>
  function myAsyncFunction (url) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();  // Создание объекта для HTTP запроса.
      xhr.open("GET", "testfile.html");  // Настройка объекта для отправки GET запроса
      xhr.onload = () => resolve(xhr.responseText);
      xhr.onerror = () => reject(xhr.statusText);
      xhr.send();     // Отправка запроса
    });
  }

	Properties

	.onreadystatechange
	.readyState
	.response
	.responseText
	.responseType
	.responseURL
	.responseXML
	.status
	.statusText
	.timeout
	.upload
	.withCredentials

	Methods

	.abort()
	.getAllResponseHeaders()
	.getResponseHeader()
	.open()
	.overrideMimeType()
	.send()
	.setRequestHeader()

  xhr.open("POST", "PostHandler.ashx");
  // Content-Type - HTTP заголовок, который указывает серверу, как интерпретировать тело запроса.
  xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

  xhr.onreadystatechange = function () { // функция-обработчик срабатывает при изменении свойства readyState
  // Значения свойства readyState:
  // 0 - Метод open() еще не вызывался
  // 1 - Метод open() уже был вызван, но метод send() еще не вызывался.
  // 2 - Метод send() был вызван, но ответ от сервера еще не получен
  // 3 - Идет прием данных от сервера. Для значения 3 Firefox вызывает обработчик события несколько раз IE только один раз.
  // 4 - Ответ от сервера полностью получен (Запрос успешно завершен).
    if (xhr.readyState == 4 && xhr.status == 200) {
      document.getElementById("output").innerHTML = xhr.responseText; // текст ответа полученного с сервера.
    }
  }
			</code></pre></details></li>
	</ul>

  <details>
    <summary>Routing</summary><pre><code>
window.onpopstate // event
history.pushState() 
history.replaceState()
history.state //свойство

window.history.back();
window.history.forward();
window.history.go(-1);

location.hash
window.addEventListener("hashchange", funcRef, false);
    </code></pre>
  </details>
</div>

<div>RegExp <a href="https://learn.javascript.ru/regular-expressions"><img src="http://learn.javascript.ru/img/favicon/favicon.png" alt="learn.javascript.ru"></a>
  <ul>
<li><details><summary>знаки</summary>
  <pre><code>
  // Флаги
  i // не зависит от регистра.
  g // с этим флагом ищет все совпадения, без него только первое
  m // многострочный режим якорей ^ $
  //s // dotall, . может соответствовать \n (not work!!!)
  u // правильная работа с unicode (в firefox и edge не работает)
  y // ровно на позиции lastIndex, ни до ни после

    // Метасимволы.
  \w // латиница, цифры, подчеркивание [a-zA-Z0-9_].
  \W // все,кроме \w
  \s // любой пробельный символ (тоже самое, что [\r\n\f\v\t])
  \S // Любой не пробельный символ (тоже самое, что [^\r\n\f\v\t])
  \d // любая цифра (digit) [0-9]
  \D // не цифры
  .  // любой символ, /CS.3/ ,кроме \n
  \v // (вертикальная табуляция)
  \t // (табуляция)
  \r // (перевод каретки)
  \n // (перевод строки)
  \f // (перевод страницы)

  //экранирование
  /\./; // найти точку
  /\(text\)/; // найти (text)
  /\\/; // найти \
  /\//; // найти /
  в [] не нужно, кроме если означает что-то особенное

    // Наборы символов (любой из заданных символов)
  [RrGgBb] // Соответствие указанным символам
  [a-z] // Соответствие символам английского алфавита в нижнем регистре
  [0-9] // Соответствие указанным цифрам
  [^0-9] // Соответствие с чем угодно кроме цифр заданного диапазона
  // экранирование не нужно, кроме если означает что-то особенное
  /[tx]op/gi; // top и/или xop
  /[\w-]/; // \w or -
  /(['"])(.*?)\1/g; // \1 ссылается на первую скобочную группу
    // найти тоже самое что в первой скобочной группе
  /(?< quote>['"])(.*?)\k< quote>/g; //тоже самое по имени

  /^((?=(?< word>\w+))\k< word>\s?)*$/; // запрет catastrophic backtracking

    // Квантификатор (Кванторы)
  + //Один или несколько символов
  * //ноль и более символов
  ? //ноль или одно вхождение
  +?, *?, ?? // ленивый режим
  /\d+/; // последовательность из одной и более цифр
  /colou?r/; // color и colour
  /<\/?[a-z][a-z0-9]*>/i; // открывающий и закрывющий тег без атрибутов
  /<\/?\w+>/ // почти тоже самое

    // Интервалы
  {3} // точное количество совпадений 3
  {2,3} // диапазон 2-3
  {3,} // не менее 3
  {,3} // не более 3
  \d{5} // \d\d\d\d\d

    // Якорные символы
  ^  /^Mary/ //найдёт если это слово в начале строки
  $  /fin$/ // найдёт если это слово в конце строки
    /^\d\d[-:]\d\d$/; // время формата 12:34 или 12-34
    /^\d/gm; // цифра в начале каждой строки

//проверка
  /x(?=y)/ // x,y - любые шаблоны
  // проверяет, следует ли y за x-ом
  /x(?!y)/
  /x(?=(y))/; // дополнительные скобки включают в результат проверку

  \b // проверяет что \w только с одной стороны
    /\bJava\b/; //Java , <s>JavaScript</s>
    /\b\d\d\b/g; // отдельно стоящие двузначные числа 23

</code></pre></details></li>
    <li><details><summary>методы</summary>
      <pre><code>
  /\d\d\d/gmi // type object
  let varName = /< h2>/gm;

  let varName = new RegExp(`<${prompt()}>`);
  // метод new RegExp не требует / /
  // а \ съедается строкой "", поэтому их надо удвоить \\
  new RegExp("\\d\\.\\d"); // \d\.\d - 5.1

  str.match(/.../gi); // принимает регулярное выражение и возвращает массив с результатами поиска
        if not - return null
        let result = str.match(/<(.+?)>/); // возвращает массив с первым совпадением
        result.length // длина массива 1
        result.index // индекс совпадения
        result.input // исходная строка
        result[0] // < h1>
        result[1] // h1
    //  ?< > именование скобочных групп
    /(?< year>[0-9]{4})-(?< month>[0-9]{2})-(?< day>[0-9][2])/;
        result.groups.year;
        let {year, month, day} = result.groups;
    //  ?: исключает из запоминания
    /<(?:.+?)>/

  str.matchAll(/<(.+?)>/g); // return object массивов

  str.replace(/we/ig, "As") // заменяет найденное на As
  str.replace(/we/ig, "$& As") // "...We As..."
  let str = "John Bull";
  let regexp = /(\w+) (\w+)/;
  alert( str.replace(regexp, '$2, $1')); // Bull, John
  let regexp = /(?< year>[0-9]{4})-(?< month>[0-9]{2})-(?< day>[0-9]{2})/g;
  let str = "2019-10-30, 2020-01-01";
  alert( str.replace(regexp, '$< day>.$< month>.$< year>'));
  // 30.10.2019, 01.01.2020
  str.replace(regexp, funcName);
  str.replace(regexp, () => {});
  func(match, p1, p2, ..., pn, offset, input, groups):
match – найденное совпадение,
p1, p2, ..., pn – содержимое скобок (см. главу Скобочные группы).
offset – позиция, на которой найдено совпадение,
input – исходная строка,
groups – объект с содержимым именованных скобок

  pattern.exec("string") // возвращает результат поиска по шаблону(только 1й, если не задано g)

  pattern.test("string") // проверяет соответствие с шаблоном
    /love/i.test("i love java"); // true

  pattern.lastIndex; // позиция за совпадением 3, до начала поиска 0
    pattern.lastIndex = 4; // начать поиск с позиции 4

("+7(903)-123-45-67").match(/\d/g).join(''); // "79031234567" находим цифры и соединяем
("+7(903)-123-45-67").replace(/\D/g, ""); // "79031234567" убираем не цифры
("+7(903)-123-45-67").match(/\d+/); // 7,903,123,45,67
</code></pre></details></li>
<li><details><summary>patterns</summary>
  <pre><code>
/[-.\w]+@([\w-]+\.)+\w+/g; // email
/(https?:\/\/)?(www\.)?[a-z0-9-\.]{2,30}\.ru/gi; 
  //для поиска веб-сайтов с доменом .ru
/([01]\d|2[0-3])[-:][0-5]\d/g; //  время формата 12:04 или 23-54

/<.+?>/g // любой тег с атрибутами
/<тег.*?>/g; // конкретный тег с атрибутами
/<(teg).*?>(.|\n)*?<\/\1>/g; // парный тег с атрибутами и содержимым

/[-\d.]+\b/g; // любое десятичное число
/([-\d.]+\b) ?([-+*/]) ?([-\d.]+\b)/g; //арифметические выражения
/x[0-9A-F]{2}/g; // шестнадцатеричное число xAF
/#([0-9A-F]{3}){1,2}\b/gi; // color #af23cd и #ae6
/\[(.+?)\](.|\n)+?\[\/\1\]/g; // bb-коды
</code></pre></details></li>
<li><details><summary>unicode</summary>
  <pre><code class="js">
    <a href="https://learn.javascript.ru/regexp-unicode">learn.javascript.ru</a>
  u // правильная работа с unicode (в firefox и edge не работает)
/\p{L}/gu; // найдёт все буквы любого алфавита

Буквы L:
  в нижнем регистре Ll,
  модификаторы Lm,
  заглавные буквы Lt,
  в верхнем регистре Lu,
  прочие Lo.
Числа N:
  десятичная цифра Nd,
  цифры обозначаемые буквами (римские) Nl,
  прочие No.
Знаки пунктуации P:
  соединители Pc,
  тире Pd,
  открывающие кавычки Pi,
  закрывающие кавычки Pf,
  открывающие скобки Ps,
  закрывающие скобки Pe,
  прочее Po.
Отметки M (например, акценты):
  двоеточия Mc,
  вложения Me,
  апострофы Mn.
Символы S:
  валюты Sc,
  модификаторы Sk,
  математические Sm,
  прочие So.
Разделители Z:
  линия Zl,
  параграф Zp,
  пробел Zs.
Прочие C:
  контрольные Cc,
  форматирование Cf,
  не назначенные Cn,
  для приватного использования Co,
  суррогаты Cs.

"число: xAF".match(/x\p{Hex_Digit}\p{Hex_Digit}/u); // xAF
Hex_Digit //шестнадцатеричные числа
/\p{sc=Cyrillic}/gu; // найдёт кириллические символы
/\p{sc=Han}/gu; // найдёт китайские иероглифы
/\p{Sc}\d/gu; //  найдёт валюту

\p{Alpha}  // буквы
\p{Join_C} // два специальных кода 200c и 200d, используемые в лигатурах, например арабских
  </code></pre></details></li>

  </ul>
</div>


<div>
<pre>
        <a title="Оператор with создает новую область видимости и 
    представляет свойства объекта «object» как локальные переменные. 
    
    Оператор with является устаревшим и его использование не желательно. 
    Его использование запрещено в Strict Mode. 
    Подробнее: http://habrahabr.ru/post/118666/">with </a>

            .anchors[0].name

    Кэширование изображений

        let images = []

        function preload() {
            for (let i in preload.arguments) {
                images[i] = new Image()
                images[i].src = preload.arguments[i]
            }
        }

        preload(
            "images/frame1.jpg",
            "images/frame2.jpg",
            "images/frame3.jpg",
            "images/frame4.jpg",
            "images/frame5.jpg"
        )
        или
        (new Image()).src = "images/button-hover.jpg";

типизированные массивы
отражения
<hr>

stylelint-no-unsupported-browser-features
eslint-plugin-compat
в теге script атрибут <a href="https://bitsofco./async-vs-defer/"> defer / async</a>

</pre>
codepen: 
<ul>
	<li><a href="https://codepen.io/leonardasf1/pen/voBMPL">create a paragraph</a></li>
	<li><a href="https://codepen.io/leonardasf1/pen/aeoMRE">pattern.exec</a></li>
	<li><a href="https://codepen.io/leonardasf1/pen/XLvymR">svetofor</a></li>
	<li><a href="https://codepen.io/leonardasf1/pen/rEXrgv">Ugadai random number</a></li>
	<li><a href="https://codepen.io/leonardasf1/pen/JQgNWb">Tooltip</a></li>
	<li><a href="https://codepen.io/leonardasf1/pen/VJoPbq">Calculator</a></li>
	<li><a href="https://codepen.io/leonardasf1/pen/PoYgPXz">Sort</a></li>
</ul>
</div>